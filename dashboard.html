<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Dashboard | RouteFlow London</title>
  <link rel="icon" href="images/New_Routflow_London_Logo.png" type="image/png" />
  <link href="https://fonts.googleapis.com/css2?family=Atkinson+Hyperlegible:wght@400;600&family=Inter:wght@400;600;800&display=swap" rel="stylesheet" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />
  <link rel="stylesheet" href="style.css" />
  <link rel="stylesheet" href="dashboard.css" />
  <script src="theme.js" defer></script>
  <script src="site.js" defer></script>
</head>
<body>
  <a class="skip-link" href="#main-content">Skip to main content</a>
  <div id="navbar-container"></div>
  <section
    class="auth-gate"
    id="dashboardAuthGate"
    role="alertdialog"
    aria-modal="true"
    aria-labelledby="dashboardGateTitle"
    aria-live="assertive"
    hidden
  >
    <div class="auth-gate__panel">
      <p class="auth-gate__eyebrow">Progress locked</p>
      <h2 class="auth-gate__title" id="dashboardGateTitle">Log in to activate the RouteFlow dashboard</h2>
      <p class="auth-gate__message" data-auth-gate-message>Sign in to unlock this area.</p>
      <button type="button" class="auth-gate__cta" data-auth-gate-login>
        <i class="fa-solid fa-lock-open" aria-hidden="true"></i>
        <span>Sign in to continue</span>
      </button>
      <p class="auth-gate__hint">Routes, disruptions and the Info hub remain public for everyone.</p>
    </div>
  </section>
  <main id="main-content" class="dashboard" aria-labelledby="dashboard-title" data-auth-locked="true">
    <section class="dashboard-hero card" data-animate="fade-up" data-locked-section data-lock-label="Sign in">
      <div class="dashboard-hero__profile">
        <img src="user-icon.png" alt="User Avatar" id="profileAvatar" />
        <div>
          <p class="dashboard-hero__eyebrow">RouteFlow progression</p>
          <h1 id="dashboard-title">Welcome</h1>
          <p id="profileInfo" class="dashboard-hero__hint"></p>
          <div class="dashboard-hero__xp" role="group" aria-label="Experience progress">
            <div class="dashboard-hero__xp-top">
              <span class="dashboard-hero__level">Level <strong id="levelNumber">1</strong></span>
              <span class="dashboard-hero__xp-balance"><strong id="xpValue">0</strong> XP</span>
            </div>
            <div class="dashboard-hero__progress" aria-hidden="true">
              <div class="dashboard-hero__progress-bar" id="xpProgressBar"></div>
            </div>
            <p class="dashboard-hero__progress-copy"><span id="xpToNext">0</span> XP until the next level.</p>
            <p class="dashboard-hero__progress-copy" id="dailyCapCopy"><span id="dailyCapText">Daily cap: 0 XP remaining</span></p>
          </div>
        </div>
      </div>
      <div class="dashboard-hero__actions">
        <button class="dashboard-pill" id="discordConnectButton" type="button">
          <i class="fa-brands fa-discord" aria-hidden="true"></i>
          <span id="discordStatus">Connect Discord</span>
        </button>
        <div class="dashboard-hero__stats">
          <div>
            <span>Badges</span>
            <strong id="badgeSummary">0</strong>
          </div>
          <div>
            <span>Active role</span>
            <strong id="activeRole">Explorer</strong>
          </div>
          <div>
            <span>Streak</span>
            <strong id="streakValue">0</strong>
          </div>
          <div>
            <span>Combo chain</span>
            <strong id="comboValue">0</strong>
          </div>
        </div>
      </div>
    </section>

    <section class="dashboard-grid">
      <article class="card dashboard-card" id="tasksCard" data-locked-section data-lock-label="Sign in">
        <header class="dashboard-card__header">
          <div>
            <p class="dashboard-card__eyebrow">Daily boosters</p>
            <h2>Complete tasks to earn XP</h2>
          </div>
          <button type="button" class="dashboard-card__action" id="resetTasksButton">Reset tasks</button>
        </header>
        <ul class="dashboard-task-list" id="taskList"></ul>
      </article>

      <article class="card dashboard-card" id="badgesCard" data-locked-section data-lock-label="Sign in">
        <header class="dashboard-card__header">
          <div>
            <p class="dashboard-card__eyebrow">Badge cabinet</p>
            <h2>Showcase your London achievements</h2>
          </div>
          <span class="dashboard-card__meta" id="badgeCountLabel">0 badges</span>
        </header>
        <div class="dashboard-badge-grid" id="badgeGrid"></div>
      </article>

      <article class="card dashboard-card" id="rolesCard" data-locked-section data-lock-label="Sign in">
        <header class="dashboard-card__header">
          <div>
            <p class="dashboard-card__eyebrow">Role sync</p>
            <h2>One identity across web and Discord</h2>
          </div>
          <span class="dashboard-card__meta" id="roleSyncStatus">Not linked</span>
        </header>
        <div class="dashboard-role-grid" id="roleList"></div>
      </article>

      <article class="card dashboard-card" id="miniGamesCard" data-locked-section data-lock-label="Sign in">
        <header class="dashboard-card__header">
          <div>
            <p class="dashboard-card__eyebrow">Mini games</p>
            <h2>Play for streaks and bonus XP</h2>
          </div>
          <span class="dashboard-card__meta" id="miniGameSummary">0 games</span>
        </header>
        <div class="dashboard-mini-grid" id="miniGameList"></div>
      </article>

      <article class="card dashboard-card" id="challengesCard" data-locked-section data-lock-label="Sign in">
        <header class="dashboard-card__header">
          <div>
            <p class="dashboard-card__eyebrow">Challenges</p>
            <h2>Weekly goals and combo chains</h2>
          </div>
          <span class="dashboard-card__meta" id="challengeSummary">Track your streaks</span>
        </header>
        <div class="dashboard-challenge-grid">
          <section aria-labelledby="weeklyChallengesTitle">
            <h3 id="weeklyChallengesTitle">Weekly challenges</h3>
            <ul class="dashboard-challenge-list" id="weeklyChallengeList"></ul>
          </section>
          <section aria-labelledby="comboChallengesTitle">
            <h3 id="comboChallengesTitle">Combo milestones</h3>
            <ul class="dashboard-challenge-list" id="comboChallengeList"></ul>
          </section>
        </div>
      </article>

      <article class="card dashboard-card" id="missionsCard" data-locked-section data-lock-label="Sign in">
        <header class="dashboard-card__header">
          <div>
            <p class="dashboard-card__eyebrow">Missions</p>
            <h2>Meaningful contributions earn more XP</h2>
          </div>
          <span class="dashboard-card__meta" id="missionSummary">0 missions</span>
        </header>
        <ul class="dashboard-mission-list" id="missionList"></ul>
      </article>

      <article class="card dashboard-card" id="activityCard" data-locked-section data-lock-label="Sign in">
        <header class="dashboard-card__header">
          <div>
            <p class="dashboard-card__eyebrow">Timeline</p>
            <h2>Recent activity</h2>
          </div>
        </header>
        <ul id="activityList" class="activity-list"></ul>
      </article>

      <article class="card dashboard-card" data-locked-section data-lock-label="Sign in">
        <header class="dashboard-card__header">
          <div>
            <p class="dashboard-card__eyebrow">Saved stops</p>
            <h2>Your favourites</h2>
          </div>
        </header>
        <div id="favouritesGrid" class="favourites-grid"></div>
      </article>

      <article class="card dashboard-card" data-locked-section data-lock-label="Sign in">
        <header class="dashboard-card__header">
          <div>
            <p class="dashboard-card__eyebrow">Quick access</p>
            <h2>Recent pages</h2>
          </div>
        </header>
        <ul id="recentsList" class="recents-list"></ul>
      </article>
    </section>
  </main>

  <dialog class="dashboard-dialog" id="miniGameDialog" aria-modal="true">
    <form method="dialog" class="dashboard-dialog__surface">
      <header class="dashboard-dialog__header">
        <h2 id="miniGameTitle">Mini game</h2>
        <button type="submit" class="dashboard-dialog__close" aria-label="Close mini game">
          <i class="fa-solid fa-xmark" aria-hidden="true"></i>
        </button>
      </header>
      <div class="dashboard-dialog__body" id="miniGameBody"></div>
      <footer class="dashboard-dialog__footer">
        <button type="submit" class="dashboard-dialog__button">Close</button>
      </footer>
    </form>
  </dialog>

  <div class="dashboard-toast" id="dashboardToast" role="status" aria-live="polite" hidden></div>

  <script src="main.js" defer></script>
  <footer class="site-footer" aria-label="Footer">
    <div class="site-footer__inner">
      <div class="site-footer__brand">
        <span class="site-footer__name">RouteFlow London</span>
        <p class="site-footer__description">Live transport guidance built to be clear for every rider.</p>
      </div>
      <nav class="site-footer__nav" aria-label="Explore">
        <a href="index.html">Home</a>
        <a href="dashboard.html">Dashboard</a>
        <a href="tracking.html">Tracking</a>
        <a href="planning.html">Planning</a>
        <a href="routes.html">Routes</a>
        <a href="info.html">Info hub</a>
      </nav>
      <nav class="site-footer__nav" aria-label="Support">
        <a href="about.html">About</a>
        <a href="contact.html">Contact</a>
        <a href="privacy.html">Privacy</a>
        <a href="terms.html">Terms</a>
        <a href="settings.html">Settings</a>
      </nav>
      <div class="site-footer__social" aria-label="Social channels">
        <a href="https://discord.gg/qVf3nN4Mgq" aria-label="RouteFlow London on Discord"><i class="fa-brands fa-discord"></i></a>
        <a href="https://www.tiktok.com/@the_bus_father" aria-label="RouteFlow London on TikTok"><i class="fab fa-tiktok"></i></a>
        <a href="https://www.instagram.com/thebusfatherofficial/profilecard/?igsh=NXcybzV3cTA2azBo" aria-label="RouteFlow London on Instagram"><i class="fab fa-instagram"></i></a>
      </div>
    </div>
    <div class="site-footer__meta">
      <span>&copy; <span data-current-year></span> RouteFlow London. All rights reserved.</span>
      <span>Made for London. Accessible for everyone.</span>
    </div>
  </footer>

  <script src="navbar-loader.js" defer></script>
  <script src="auth-guard.js" defer></script>
  <script type="module">
    import { getFavourites, removeFavourite } from './favourites.js';
    import { getRecents } from './recents.js';
    import { inferFavouriteType, resolveFavouriteTitle, buildFavouriteMeta } from './favourite-utils.js';
    import { connectDiscord, disconnectDiscord, subscribeToDiscordStatus, getDiscordStatus, isDiscordConfigured } from './discord-auth.js';

    const STORAGE_PREFIX = 'routeflow:gamification';
    const TOAST_DURATION = 4000;
    const LEVEL_CONFIG = { base: 420, growth: 1.48, maxLevel: 40 };

    const DEFAULT_GAMIFICATION = () => ({
      xp: 1820,
      streak: 1,
      dailyCap: 750,
      dailyXp: 0,
      lastDailyReset: null,
      lastLoginDate: null,
      discordConnected: false,
      combo: { current: 0, best: 0 },
      tasks: [
        {
          id: 'task-tracking',
          title: 'Verify live tracking',
          description: 'Refresh arrivals for a priority stop and log a reliability note.',
          xp: 90,
          completed: false,
          badge: 'badge-tracker',
          trigger: 'task-core'
        },
        {
          id: 'task-planning',
          title: 'Plan a multi-mode journey',
          description: 'Use accessibility filters to craft a trip with at least two modes.',
          xp: 120,
          completed: false,
          badge: 'badge-planner',
          trigger: 'task-core'
        },
        {
          id: 'task-research',
          title: 'Submit a fleet insight',
          description: 'Upload evidence for a rare working or new allocation change.',
          xp: 160,
          completed: false,
          badge: 'badge-researcher',
          trigger: 'mission-progress'
        }
      ],
      badges: [
        {
          id: 'badge-tracker',
          title: 'Pulse Watcher',
          tier: 'Bronze',
          description: 'Complete 5 live tracking sessions.',
          icon: 'fa-solid fa-wifi',
          progress: 2,
          goal: 5,
          xp: 160,
          earned: false
        },
        {
          id: 'badge-planner',
          title: 'Journey Curator',
          tier: 'Silver',
          description: 'Plan 10 multimodal trips.',
          icon: 'fa-solid fa-route',
          progress: 4,
          goal: 10,
          xp: 210,
          earned: false
        },
        {
          id: 'badge-night',
          title: 'Night Bus Navigator',
          tier: 'Event',
          description: 'Log arrivals after 23:00 for three consecutive nights.',
          icon: 'fa-solid fa-moon',
          progress: 3,
          goal: 3,
          xp: 260,
          earned: true,
          rare: true
        },
        {
          id: 'badge-researcher',
          title: 'Fleet Researcher',
          tier: 'Gold',
          description: 'Approve four operator missions.',
          icon: 'fa-solid fa-magnifying-glass-chart',
          progress: 1,
          goal: 4,
          xp: 280,
          earned: false
        },
        {
          id: 'badge-archivist',
          title: 'Hidden Archivist',
          tier: 'Hidden',
          description: 'Complete three hidden Info hub missions.',
          icon: 'fa-solid fa-lock',
          progress: 0,
          goal: 3,
          xp: 320,
          earned: false,
          hidden: true
        }
      ],
      roles: [
        {
          id: 'role-dashboard',
          platform: 'RouteFlow',
          title: 'Pathfinder',
          description: 'Unlocked automatically at Level 5.',
          requirements: { level: 5 },
          active: false
        },
        {
          id: 'role-spotter',
          platform: 'RouteFlow',
          title: 'Bus Spotter',
          description: 'Reach Level 10 and earn the Pulse Watcher badge.',
          requirements: { level: 10, badges: ['badge-tracker'] },
          active: false
        },
        {
          id: 'role-expert',
          platform: 'RouteFlow',
          title: 'Route Expert',
          description: 'Level 16 with Journey Curator and Fleet Researcher badges.',
          requirements: { level: 16, badges: ['badge-planner', 'badge-researcher'] },
          active: false
        },
        {
          id: 'role-master',
          platform: 'Discord',
          title: 'Fleet Master',
          description: 'Level 24, rare badge unlocked and Discord linked.',
          requirements: { level: 24, badges: ['badge-night', 'badge-archivist'], discord: true },
          active: false
        }
      ],
      miniGames: [
        {
          id: 'mini-guess',
          title: 'Guess the Bus',
          description: 'Identify the working from a cryptic clue.',
          xp: 180,
          type: 'guess',
          attempts: 0,
          maxAttempts: 2
        },
        {
          id: 'mini-route',
          title: 'Route Puzzle',
          description: 'Rebuild a route by picking the correct termini.',
          xp: 210,
          type: 'puzzle',
          attempts: 0,
          maxAttempts: 1
        },
        {
          id: 'mini-streak',
          title: 'Streak Builder',
          description: 'Lock in today’s streak bonus without missing a day.',
          xp: 150,
          type: 'streak',
          attempts: 0,
          maxAttempts: 1
        }
      ],
      weeklyChallenges: [
        {
          id: 'weekly-research',
          title: 'Research Relay',
          description: 'Complete three missions approved by admins this week.',
          progress: 1,
          goal: 3,
          xp: 220,
          penalty: 'Missing a day drops progress by one.',
          trigger: 'mission-complete'
        },
        {
          id: 'weekly-streak',
          title: 'Streak Sentinel',
          description: 'Maintain a five-day login streak.',
          progress: 2,
          goal: 5,
          xp: 260,
          penalty: 'Break the streak and progress resets.',
          trigger: 'streak'
        }
      ],
      comboChallenges: [
        {
          id: 'combo-mini',
          title: 'Arcade Combo',
          description: 'Win two mini-games in a row.',
          progress: 0,
          goal: 2,
          xp: 200,
          penalty: 'A failed attempt resets the chain.',
          trigger: 'mini-win'
        },
        {
          id: 'combo-contribution',
          title: 'Contributor Combo',
          description: 'Complete three missions without missing a day.',
          progress: 1,
          goal: 3,
          xp: 280,
          penalty: 'Skip a day and the combo resets.',
          trigger: 'mission-complete'
        }
      ],
      missions: [
        {
          id: 'mission-operator',
          title: 'Operator insight upload',
          type: 'Operator',
          description: 'Submit a researched operator change with supporting evidence.',
          xp: 180,
          completed: false,
          badge: 'badge-researcher'
        },
        {
          id: 'mission-gallery',
          title: 'Fleet gallery expansion',
          type: 'Media',
          description: 'Upload two high-quality fleet images to the carousel.',
          xp: 220,
          completed: false,
          badge: 'badge-archivist'
        },
        {
          id: 'mission-maps',
          title: 'Interactive map note',
          type: 'Maps',
          description: 'Add a verified accessibility note to the live network map.',
          xp: 200,
          completed: false,
          badge: null
        }
      ]
    });

    const LEVEL_THRESHOLDS = (() => {
      const thresholds = [0];
      let requirement = LEVEL_CONFIG.base;
      for (let level = 1; level <= LEVEL_CONFIG.maxLevel; level += 1) {
        thresholds[level] = Math.round((thresholds[level - 1] || 0) + requirement);
        requirement *= LEVEL_CONFIG.growth;
      }
      return thresholds;
    })();

    let currentUid = 'guest';
    let gamificationState = DEFAULT_GAMIFICATION();
    let toastTimeout;

    const rootElement = document.querySelector('.dashboard');
    const overlayElement = document.getElementById('dashboardAuthGate');
    const lockedSections = document.querySelectorAll('[data-locked-section]');

    const toast = document.getElementById('dashboardToast');
    const levelNumber = document.getElementById('levelNumber');
    const xpValue = document.getElementById('xpValue');
    const xpToNext = document.getElementById('xpToNext');
    const xpProgressBar = document.getElementById('xpProgressBar');
    const badgeSummary = document.getElementById('badgeSummary');
    const badgeCountLabel = document.getElementById('badgeCountLabel');
    const roleSyncStatus = document.getElementById('roleSyncStatus');
    const miniGameSummary = document.getElementById('miniGameSummary');
    const streakValue = document.getElementById('streakValue');
    const activeRole = document.getElementById('activeRole');
    const discordButton = document.getElementById('discordConnectButton');
    const discordStatus = document.getElementById('discordStatus');
    const dailyCapCopy = document.getElementById('dailyCapCopy');
    const dailyCapText = document.getElementById('dailyCapText');
    const comboValue = document.getElementById('comboValue');
    const challengeSummary = document.getElementById('challengeSummary');
    const missionSummary = document.getElementById('missionSummary');
    const missionList = document.getElementById('missionList');
    const weeklyChallengeList = document.getElementById('weeklyChallengeList');
    const comboChallengeList = document.getElementById('comboChallengeList');
    const titleElement = document.getElementById('dashboard-title');
    const infoElement = document.getElementById('profileInfo');
    const avatarElement = document.getElementById('profileAvatar');
    const miniGameDialog = document.getElementById('miniGameDialog');
    const miniGameTitle = document.getElementById('miniGameTitle');
    const miniGameBody = document.getElementById('miniGameBody');
    const resetTasksButton = document.getElementById('resetTasksButton');

    let discordConnection = getDiscordStatus();
    let unsubscribeDiscord = null;

    const levelLocks = [
      { element: document.getElementById('rolesCard'), level: 5, label: 'Reach Level 5' },
      { element: document.getElementById('miniGamesCard'), level: 3, label: 'Reach Level 3' },
      { element: document.getElementById('challengesCard'), level: 6, label: 'Reach Level 6' },
      { element: document.getElementById('missionsCard'), level: 8, label: 'Level 8 + badges' }
    ];

    const randomItem = (collection) => {
      if (!Array.isArray(collection) || collection.length === 0) {
        return null;
      }
      const index = Math.floor(Math.random() * collection.length);
      return collection[index];
    };

    const shuffleArray = (collection) => {
      if (!Array.isArray(collection)) return [];
      const copy = collection.slice();
      for (let i = copy.length - 1; i > 0; i -= 1) {
        const j = Math.floor(Math.random() * (i + 1));
        [copy[i], copy[j]] = [copy[j], copy[i]];
      }
      return copy;
    };

    const MINI_GAME_BANK = Object.freeze({
      guess: [
        {
          id: 'guess-heritage',
          prompt: 'Which registration carries the heritage wrap that turns heads on Route 11?',
          hint: 'Think New Routemasters with gold accents.',
          answers: [
            { id: 'ltz1000', text: 'LTZ 1000', correct: true, explanation: 'LTZ1000 is Go-Ahead London’s flagship New Routemaster running the heritage duties.' },
            { id: 'bv72ykd', text: 'BV72 YKD', explanation: 'Abellio’s newest Enviro400EV with route branding, not the heritage wrap.' },
            { id: 'sn68aeo', text: 'SN68 AEO', explanation: 'Stagecoach’s hybrid Enviro400 MMC that focuses on the 97 out of Leyton.' },
            { id: 'lj68awu', text: 'LJ68 AWU', explanation: 'A modern double decker on the 29 — no heritage wrap here.' }
          ]
        },
        {
          id: 'guess-electric',
          prompt: 'Spot the brand-new electric joining Battersea’s Superloop launch.',
          hint: 'Look for the registration that begins with BV.',
          answers: [
            { id: 'bv72ykd', text: 'BV72 YKD', correct: true, explanation: 'BV72 YKD is Abellio’s Enviro400EV based at Battersea (QB) for Superloop duties.' },
            { id: 'ltz1000', text: 'LTZ 1000', explanation: 'Iconic, but it is a heritage Routemaster rather than the new EV.' },
            { id: 'sn68aeo', text: 'SN68 AEO', explanation: 'Runs with Stagecoach in East London rather than the south-west Superloop.' },
            { id: 'lr61bde', text: 'LR61 BDE', explanation: 'A withdrawn Trident from the archive, not a current EV.' }
          ]
        },
        {
          id: 'guess-night',
          prompt: 'Which vehicle is tagged as a rare working with night duties in the fleet tools?',
          hint: 'Check the extras column for the Night Bus allocation tag.',
          answers: [
            { id: 'sn68aeo', text: 'SN68 AEO', correct: true, explanation: 'SN68 AEO is flagged for Night Bus allocation in the RouteFlow fleet database.' },
            { id: 'bv72ykd', text: 'BV72 YKD', explanation: 'Marked as a new bus with route branding, not as a night working.' },
            { id: 'ltz1000', text: 'LTZ 1000', explanation: 'Heritage star, but not recorded for night duty allocations.' },
            { id: 'yy11abc', text: 'YY11 ABC', explanation: 'A decoy registration with no entry in the live records.' }
          ]
        }
      ],
      puzzle: [
        {
          id: 'puzzle-superloop',
          prompt: 'Rebuild the outer-orbital link: which termini define Superloop SL8?',
          hint: 'It mirrors the old X140 express corridor.',
          answers: [
            { id: 'uxbridge-whitecity', text: 'Uxbridge — White City', correct: true, explanation: 'SL8 links Uxbridge with White City through the Northolt corridor.' },
            { id: 'croydon-harrow', text: 'Croydon — Harrow', explanation: 'That pairing matches the proposed SL5 instead.' },
            { id: 'bexleyheath-stratford', text: 'Bexleyheath — Stratford', explanation: 'Those termini belong to the planned SL2 service.' },
            { id: 'walthamstow-ealing', text: 'Walthamstow — Ealing Broadway', explanation: 'This duo lines up with Superloop SL1, not SL8.' }
          ]
        },
        {
          id: 'puzzle-nightbus',
          prompt: 'You’re mapping the N279 for a late-night briefing. Where does it start and finish?',
          hint: 'Think about the A10 spine north of the river.',
          answers: [
            { id: 'walthamcross-trafalgar', text: 'Waltham Cross — Trafalgar Square', correct: true, explanation: 'N279 runs between Waltham Cross and Trafalgar Square via Tottenham and the A10.' },
            { id: 'croydon-piccadilly', text: 'Croydon — Piccadilly Circus', explanation: 'Closer to the N68 alignment than the N279.' },
            { id: 'harrow-lewisham', text: 'Harrow — Lewisham', explanation: 'This mixes two separate night routes into one fictional service.' },
            { id: 'stratford-oxfordcircus', text: 'Stratford — Oxford Circus', explanation: 'That’s more akin to the N205’s coverage.' }
          ]
        }
      ],
      streak: [
        {
          id: 'streak-journal',
          prompt: 'You’re four days into a streak but heading out to film late-night workings. How do you keep it alive?',
          answers: [
            { id: 'log-note', text: 'Log a quick dashboard note before midnight from your phone.', correct: true, explanation: 'Any logged activity before midnight keeps the streak and combo intact.' },
            { id: 'double-update', text: 'Wait until morning and post two updates together.', explanation: 'Missing midnight breaks the streak even if you post twice tomorrow.' },
            { id: 'claim-badge', text: 'Claim a badge tomorrow instead of logging tonight.', explanation: 'Badge claims don’t backdate missed days.' },
            { id: 'save-draft', text: 'Save a fleet draft offline and upload it next week.', explanation: 'Drafts without submission do not count as daily activity.' }
          ]
        },
        {
          id: 'streak-refresh',
          prompt: 'The combo timer flashes red with two hours left. What action protects both the streak and combo?',
          answers: [
            { id: 'refresh-tracking', text: 'Refresh a tracked stop and log a reliability note right now.', correct: true, explanation: 'Logging live tracking immediately extends both the streak and combo timers.' },
            { id: 'toggle-theme', text: 'Switch the site theme to dark mode and back again.', explanation: 'Theme changes are personal preference and don’t count towards streaks.' },
            { id: 'share-social', text: 'Post a screenshot to social media without logging it here.', explanation: 'External shares are great, but only in-app actions extend the streak.' },
            { id: 'delay-settings', text: 'Wait until tomorrow to update a settings preference.', explanation: 'Delaying until tomorrow lets the streak lapse overnight.' }
          ]
        }
      ]
    });

    const guard = window.RouteflowAuthGate?.create({
      root: rootElement,
      overlay: overlayElement,
      lockedSections,
      lockedMessage: 'Sign in to work through missions and unlock challenging rewards.',
      errorMessage: 'Authentication is temporarily unavailable. Please try again later.',
      onLock: handleLock,
      onUnlock: handleUnlock
    });

    function storageKey(uid) {
      return `${STORAGE_PREFIX}:${uid || 'guest'}`;
    }

    function safeParse(value) {
      try {
        return value ? JSON.parse(value) : null;
      } catch (error) {
        console.warn('RouteFlow dashboard: failed to parse stored gamification state', error);
        return null;
      }
    }

    function loadState(uid) {
      try {
        const stored = safeParse(localStorage.getItem(storageKey(uid)));
        if (stored && typeof stored === 'object') {
          const fallback = DEFAULT_GAMIFICATION();
          return {
            ...fallback,
            ...stored,
            combo: { ...fallback.combo, ...(stored.combo || {}) },
            tasks: (stored.tasks || fallback.tasks).map((task) => ({ ...task })),
            badges: (stored.badges || fallback.badges).map((badge) => ({ ...badge })),
            roles: (stored.roles || fallback.roles).map((role) => ({ ...role })),
            miniGames: (stored.miniGames || fallback.miniGames).map((game) => ({ ...game })),
            weeklyChallenges: (stored.weeklyChallenges || fallback.weeklyChallenges).map((item) => ({ ...item })),
            comboChallenges: (stored.comboChallenges || fallback.comboChallenges).map((item) => ({ ...item })),
            missions: (stored.missions || fallback.missions).map((mission) => ({ ...mission }))
          };
        }
      } catch (error) {
        console.warn('RouteFlow dashboard: unable to load gamification state', error);
      }
      return DEFAULT_GAMIFICATION();
    }

    function saveState() {
      try {
        localStorage.setItem(storageKey(currentUid), JSON.stringify(gamificationState));
      } catch (error) {
        console.warn('RouteFlow dashboard: unable to save gamification state', error);
      }
    }

    function showToast(message) {
      if (!toast) return;
      toast.textContent = message;
      toast.hidden = false;
      toast.classList.add('is-visible');
      clearTimeout(toastTimeout);
      toastTimeout = setTimeout(() => {
        toast.classList.remove('is-visible');
        toast.hidden = true;
      }, TOAST_DURATION);
    }

    function formatNumber(value) {
      return new Intl.NumberFormat('en-GB').format(value);
    }

    function todayKey() {
      return new Date().toISOString().slice(0, 10);
    }

    function daysBetween(current, previous) {
      if (!current || !previous) return Infinity;
      const currentDate = new Date(current);
      const previousDate = new Date(previous);
      if (!Number.isFinite(currentDate.getTime()) || !Number.isFinite(previousDate.getTime())) {
        return Infinity;
      }
      return Math.round((currentDate - previousDate) / 86400000);
    }

    function ensureDailyState(state) {
      let dayDifference = null;
      if (!state) return { dayDifference };
      const today = todayKey();
      if (state.lastDailyReset !== today) {
        state.dailyXp = 0;
        state.lastDailyReset = today;
        state.miniGames = state.miniGames.map((game) => ({ ...game, attempts: 0 }));
      }
      if (!state.combo) {
        state.combo = { current: 0, best: 0 };
      }
      const previousLogin = state.lastLoginDate;
      if (previousLogin !== today) {
        const diff = daysBetween(today, previousLogin);
        if (Number.isFinite(diff)) {
          dayDifference = diff;
          if (diff === 1) {
            state.streak = (state.streak || 0) + 1;
          } else if (diff > 1) {
            state.streak = 1;
            state.combo.best = Math.max(state.combo.best || 0, state.combo.current || 0);
            state.combo.current = 0;
            state.weeklyChallenges = state.weeklyChallenges.map((challenge) => {
              const reduced = Math.max(0, (challenge.progress || 0) - 1);
              return { ...challenge, progress: reduced, missed: challenge.progress > reduced };
            });
            state.comboChallenges = state.comboChallenges.map((challenge) => ({
              ...challenge,
              progress: 0,
              missed: challenge.progress > 0
            }));
          } else {
            state.streak = state.streak || 1;
          }
        }
        state.lastLoginDate = today;
      }
      state.combo.best = Math.max(state.combo.best || 0, state.combo.current || 0);
      return { dayDifference };
    }

    function calculateLevel(xp) {
      let level = 1;
      for (let i = 1; i < LEVEL_THRESHOLDS.length; i += 1) {
        if (xp >= LEVEL_THRESHOLDS[i]) {
          level = i + 1;
        } else {
          break;
        }
      }
      const prev = LEVEL_THRESHOLDS[level - 1] ?? 0;
      const nextRequirement = LEVEL_THRESHOLDS[level] ?? Math.round(prev + LEVEL_CONFIG.base * Math.pow(LEVEL_CONFIG.growth, level - 1));
      const progress = Math.min(1, (xp - prev) / (nextRequirement - prev));
      return { level, prev, next: nextRequirement, progress };
    }

    function updateLevelLocks(level) {
      levelLocks.forEach((lock) => {
        if (!lock.element) return;
        if (level >= lock.level) {
          lock.element.removeAttribute('data-locked');
          lock.element.removeAttribute('data-lock-label');
        } else {
          lock.element.setAttribute('data-locked', 'true');
          lock.element.setAttribute('data-lock-label', lock.label);
        }
      });
    }

    function updateLevelUI() {
      const { xp, streak, dailyCap = 0, dailyXp = 0, combo } = gamificationState;
      const { level, next, prev, progress } = calculateLevel(xp);
      if (levelNumber) levelNumber.textContent = level;
      if (xpValue) xpValue.textContent = formatNumber(xp);
      const remaining = Math.max(0, next - xp);
      if (xpToNext) xpToNext.textContent = formatNumber(remaining);
      if (xpProgressBar) xpProgressBar.style.setProperty('--progress', `${Math.round(progress * 100)}%`);
      if (streakValue) streakValue.textContent = formatNumber(streak || 0);
      const capRemaining = Math.max(0, dailyCap - dailyXp);
      if (dailyCapText) {
        dailyCapText.textContent = capRemaining > 0
          ? `Daily cap: ${formatNumber(capRemaining)} XP remaining`
          : 'Daily cap reached — meaningful contributions reset tomorrow.';
      }
      if (comboValue) {
        comboValue.textContent = formatNumber(combo?.current || 0);
      }
      updateLevelLocks(level);
      return level;
    }

    function renderTasks() {
      const list = document.getElementById('taskList');
      if (!list) return;
      list.innerHTML = '';
      gamificationState.tasks.forEach((task) => {
        const item = document.createElement('li');
        item.className = `dashboard-task${task.completed ? ' is-complete' : ''}`;
        item.innerHTML = `
          <div class="dashboard-task__text">
            <strong>${task.title}</strong>
            <p>${task.description}</p>
          </div>
          <div class="dashboard-task__meta">
            <span class="dashboard-task__xp">+${task.xp} XP</span>
            <button type="button" class="dashboard-task__button" data-task="${task.id}" ${task.completed ? 'disabled' : ''}>
              ${task.completed ? 'Completed' : 'Complete'}
            </button>
          </div>
        `;
        list.appendChild(item);
      });
    }

    function resolveBadgeView(badge) {
      const isHidden = badge.hidden && !badge.earned && (badge.progress || 0) === 0;
      const title = isHidden ? 'Hidden challenge' : badge.title;
      const description = isHidden ? 'Keep exploring RouteFlow London to reveal this badge.' : badge.description;
      return { title, description };
    }

    function renderBadges() {
      const grid = document.getElementById('badgeGrid');
      if (!grid) return;
      grid.innerHTML = '';
      let earnedCount = 0;
      gamificationState.badges.forEach((badge) => {
        if (badge.earned) earnedCount += 1;
        const progressValue = Math.min(1, badge.goal ? (badge.progress || 0) / badge.goal : 1);
        const { title, description } = resolveBadgeView(badge);
        const card = document.createElement('article');
        card.className = `dashboard-badge${badge.earned ? ' is-earned' : ''}`;
        card.innerHTML = `
          <div class="dashboard-badge__icon" aria-hidden="true"><i class="${badge.icon}"></i></div>
          <div class="dashboard-badge__content">
            <div class="dashboard-badge__header">
              <h3>${title}</h3>
              <span class="dashboard-badge__tier">${badge.tier || 'Bronze'}</span>
            </div>
            <p>${description}</p>
            <div class="dashboard-badge__progress" role="progressbar" aria-valuemin="0" aria-valuemax="${badge.goal}" aria-valuenow="${Math.min(badge.progress || 0, badge.goal)}">
              <div class="dashboard-badge__progress-bar" style="--progress:${Math.round(progressValue * 100)}%"></div>
            </div>
            <div class="dashboard-badge__footer">
              <span>${badge.goal ? `${Math.min(badge.progress || 0, badge.goal)} / ${badge.goal}` : 'Complete'}</span>
              <span class="dashboard-badge__xp">${badge.xp} XP</span>
              ${!badge.earned && progressValue >= 1 ? `<button type="button" class="dashboard-badge__claim" data-claim="${badge.id}">Claim</button>` : ''}
            </div>
          </div>
        `;
        grid.appendChild(card);
      });
      if (badgeSummary) badgeSummary.textContent = earnedCount;
      if (badgeCountLabel) {
        badgeCountLabel.textContent = `${earnedCount}/${gamificationState.badges.length} badges earned`;
      }
    }

    function meetsRoleRequirements(role, level) {
      const requirements = role.requirements || {};
      if (requirements.level && level < requirements.level) {
        return false;
      }
      if (requirements.discord && !gamificationState.discordConnected) {
        return false;
      }
      if (Array.isArray(requirements.badges) && requirements.badges.length) {
        const earned = new Set(
          gamificationState.badges.filter((badge) => badge.earned).map((badge) => badge.id)
        );
        return requirements.badges.every((badgeId) => earned.has(badgeId));
      }
      return true;
    }

    function renderRoles(level) {
      const container = document.getElementById('roleList');
      if (!container) return;
      container.innerHTML = '';
      let activeLabel = 'Explorer';
      gamificationState.roles = gamificationState.roles.map((role) => {
        const unlocked = meetsRoleRequirements(role, level);
        const nextState = { ...role, active: unlocked };
        const card = document.createElement('article');
        card.className = `dashboard-role${unlocked ? ' is-active' : ''}`;
        const requirementParts = [];
        if (role.requirements?.level) requirementParts.push(`Level ${role.requirements.level}`);
        if (Array.isArray(role.requirements?.badges) && role.requirements.badges.length) requirementParts.push('Badge requirements met');
        if (role.requirements?.discord) requirementParts.push('Discord linked');
        card.innerHTML = `
          <header>
            <span class="dashboard-role__platform">${role.platform}</span>
            <h3>${role.title}</h3>
          </header>
          <p>${role.description}</p>
          <span class="dashboard-role__status">${unlocked ? 'Active' : `Locked · ${requirementParts.join(' · ')}`}</span>
        `;
        container.appendChild(card);
        if (unlocked && !role.requirements?.discord) {
          activeLabel = role.title;
        }
        return nextState;
      });
      if (activeRole) activeRole.textContent = activeLabel;
      if (roleSyncStatus) {
        roleSyncStatus.textContent = gamificationState.discordConnected ? 'Synced' : 'Not linked';
      }
    }

    function renderMiniGames() {
      const container = document.getElementById('miniGameList');
      if (!container) return;
      container.innerHTML = '';
      let totalAttempts = 0;
      let remainingAttempts = 0;
      gamificationState.miniGames.forEach((game) => {
        const attempts = game.attempts || 0;
        totalAttempts += game.maxAttempts;
        const left = Math.max(0, game.maxAttempts - attempts);
        remainingAttempts += left;
        const card = document.createElement('article');
        card.className = 'dashboard-mini';
        card.innerHTML = `
          <h3>${game.title}</h3>
          <p>${game.description}</p>
          <div class="dashboard-mini__footer">
            <span class="dashboard-mini__xp">${game.xp} XP</span>
            <button type="button" data-mini-game="${game.id}" class="dashboard-mini__button" ${left === 0 ? 'disabled' : ''}>${left === 0 ? 'Locked' : 'Play'}</button>
          </div>
          <p class="dashboard-mini__hint">${left} attempt${left === 1 ? '' : 's'} left today</p>
        `;
        container.appendChild(card);
      });
      if (miniGameSummary) {
        miniGameSummary.textContent = `${remainingAttempts}/${totalAttempts} attempts left today`;
      }
    }

    function renderChallenges() {
      if (!weeklyChallengeList || !comboChallengeList) return;
      weeklyChallengeList.innerHTML = '';
      comboChallengeList.innerHTML = '';
      const weeklyComplete = gamificationState.weeklyChallenges.filter((challenge) => challenge.progress >= challenge.goal).length;
      const comboComplete = gamificationState.comboChallenges.filter((challenge) => challenge.progress >= challenge.goal).length;

      const renderChallenge = (target, challenge) => {
        const percent = Math.min(100, Math.round(((challenge.progress || 0) / challenge.goal) * 100));
        const item = document.createElement('li');
        item.className = 'dashboard-challenge';
        if (challenge.progress >= challenge.goal) {
          item.dataset.status = 'complete';
        } else if (challenge.missed) {
          item.dataset.status = 'missed';
        }
        item.innerHTML = `
          <div class="dashboard-mission__title">
            <strong>${challenge.title}</strong>
            <span>${challenge.xp} XP</span>
          </div>
          <p class="dashboard-mission__copy">${challenge.description}</p>
          <div class="dashboard-challenge__meta">
            <span>${Math.min(challenge.progress || 0, challenge.goal)} / ${challenge.goal}</span>
            <span>${Math.max(0, challenge.goal - (challenge.progress || 0))} to go</span>
          </div>
          <div class="dashboard-challenge__progress" role="progressbar" aria-valuemin="0" aria-valuemax="${challenge.goal}" aria-valuenow="${Math.min(challenge.progress || 0, challenge.goal)}">
            <div class="dashboard-challenge__progress-bar" style="--progress:${percent}%"></div>
          </div>
          ${challenge.penalty ? `<p class="dashboard-challenge__penalty">${challenge.penalty}</p>` : ''}
        `;
        target.appendChild(item);
      };

      gamificationState.weeklyChallenges.forEach((challenge) => renderChallenge(weeklyChallengeList, challenge));
      gamificationState.comboChallenges.forEach((challenge) => renderChallenge(comboChallengeList, challenge));

      if (challengeSummary) {
        challengeSummary.textContent = `${weeklyComplete}/${gamificationState.weeklyChallenges.length} weekly • ${comboComplete}/${gamificationState.comboChallenges.length} combo complete`;
      }
    }

    function renderMissions() {
      if (!missionList) return;
      missionList.innerHTML = '';
      let completed = 0;
      gamificationState.missions.forEach((mission) => {
        if (mission.completed) completed += 1;
        const item = document.createElement('li');
        item.className = 'dashboard-mission';
        if (mission.completed) {
          item.dataset.status = 'complete';
        }
        item.innerHTML = `
          <div class="dashboard-mission__title">
            <strong>${mission.title}</strong>
            <span>${mission.type}</span>
          </div>
          <p class="dashboard-mission__copy">${mission.description}</p>
          <div class="dashboard-mission__meta">
            <span class="dashboard-mission__xp">+${mission.xp} XP</span>
            <button type="button" class="dashboard-task__button" data-mission="${mission.id}" ${mission.completed ? 'disabled' : ''}>${mission.completed ? 'Completed' : 'Log completion'}</button>
          </div>
        `;
        missionList.appendChild(item);
      });
      if (missionSummary) {
        missionSummary.textContent = `${completed}/${gamificationState.missions.length} complete`;
      }
    }

    function renderDiscordStatus() {
      if (!discordButton || !discordStatus) return;
      const connected = Boolean(discordConnection?.connected);
      const configured = isDiscordConfigured();
      discordButton.classList.toggle('is-connected', connected);
      discordButton.toggleAttribute('data-connected', connected);
      if (!configured && !connected) {
        discordButton.disabled = true;
        discordStatus.textContent = 'Discord unavailable';
        return;
      }
      discordButton.disabled = false;
      if (connected) {
        const profile = discordConnection?.profile;
        const label = profile?.displayName || profile?.username || 'Discord linked';
        discordStatus.textContent = `Connected as ${label}`;
      } else {
        discordStatus.textContent = 'Connect Discord';
      }
    }

    function renderAll() {
      const level = updateLevelUI();
      renderTasks();
      renderBadges();
      renderRoles(level);
      renderMiniGames();
      renderChallenges();
      renderMissions();
      renderDiscordStatus();
    }

    function updateDiscordConnection(status, options = {}) {
      const next = status && typeof status === 'object' ? status : { connected: false, profile: null };
      const reason = typeof next.reason === 'string' ? next.reason : null;
      const previous = Boolean(gamificationState.discordConnected);
      const connected = Boolean(next.connected);
      discordConnection = {
        connected,
        profile: next.profile || null,
        expiresAt: next.expiresAt || null,
        reason
      };
      gamificationState.discordConnected = connected;
      if (options.save !== false) {
        saveState();
      }
      const shouldRenderAll = options.renderAll !== false;
      if (shouldRenderAll) {
        renderAll();
      } else {
        renderDiscordStatus();
      }
      if (options.log !== false && connected !== previous) {
        if (reason === 'restored' || reason === 'idle') {
          return;
        }
        if (connected) {
          const label = next.profile?.displayName || next.profile?.username || 'Discord member';
          logActivity(`Discord account linked (${label})`);
        } else {
          logActivity('Discord account disconnected');
        }
      }
    }

    function registerComboProgress() {
      if (!gamificationState.combo) {
        gamificationState.combo = { current: 0, best: 0 };
      }
      gamificationState.combo.current = (gamificationState.combo.current || 0) + 1;
      gamificationState.combo.best = Math.max(gamificationState.combo.best || 0, gamificationState.combo.current);
    }

    function updateChallenges(trigger) {
      const apply = (list) => list.map((challenge) => {
        if (challenge.trigger !== trigger || challenge.progress >= challenge.goal) {
          return { ...challenge };
        }
        const progress = Math.min(challenge.goal, (challenge.progress || 0) + 1);
        return { ...challenge, progress, missed: false };
      });
      gamificationState.weeklyChallenges = apply(gamificationState.weeklyChallenges);
      gamificationState.comboChallenges = apply(gamificationState.comboChallenges);
    }

    function addXp(amount, reason, options = {}) {
      ensureDailyState(gamificationState);
      const cap = gamificationState.dailyCap || 0;
      const used = gamificationState.dailyXp || 0;
      const remaining = Math.max(0, cap - used);
      if (remaining <= 0) {
        showToast('Daily XP cap reached — come back tomorrow.');
        return 0;
      }
      const base = Math.min(amount, remaining);
      let bonus = 0;
      if (!options.skipBonus && (gamificationState.streak || 0) >= 3) {
        const multiplier = Math.min(0.5, ((gamificationState.streak || 0) - 2) * 0.05);
        bonus = Math.floor(base * multiplier);
        if (bonus > remaining - base) {
          bonus = remaining - base;
        }
      }
      const total = base + Math.max(0, bonus);
      gamificationState.dailyXp = (gamificationState.dailyXp || 0) + total;
      gamificationState.xp += total;
      if (bonus > 0) {
        logActivity(`Streak bonus applied · +${bonus} XP`);
      }
      showToast(reason ? `${reason} • +${total} XP` : `+${total} XP earned`);
      return total;
    }

    function incrementBadgeProgress(badgeId) {
      gamificationState.badges = gamificationState.badges.map((badge) => {
        if (badge.id === badgeId && !badge.earned) {
          const progress = Math.min(badge.goal, (badge.progress || 0) + 1);
          return { ...badge, progress };
        }
        return badge;
      });
    }

    function completeTask(taskId) {
      let awardedXp = 0;
      let taskTitle = '';
      gamificationState.tasks = gamificationState.tasks.map((task) => {
        if (task.id === taskId && !task.completed) {
          awardedXp = addXp(task.xp, task.title);
          taskTitle = task.title;
          if (task.badge) {
            incrementBadgeProgress(task.badge);
          }
          registerComboProgress();
          updateChallenges(task.trigger);
          return { ...task, completed: true };
        }
        return task;
      });
      if (awardedXp) {
        logActivity(`Completed task: ${taskTitle}`);
      }
      saveState();
      renderAll();
    }

    function completeMission(missionId) {
      let missionTitle = '';
      let awardedXp = 0;
      gamificationState.missions = gamificationState.missions.map((mission) => {
        if (mission.id === missionId && !mission.completed) {
          awardedXp = addXp(mission.xp, mission.title);
          missionTitle = mission.title;
          if (mission.badge) {
            incrementBadgeProgress(mission.badge);
          }
          registerComboProgress();
          updateChallenges('mission-complete');
          return { ...mission, completed: true };
        }
        return mission;
      });
      if (awardedXp) {
        logActivity(`Mission completed: ${missionTitle}`);
      }
      saveState();
      renderAll();
    }

    function claimBadge(badgeId) {
      let badgeAward = 0;
      let badgeTitle = '';
      gamificationState.badges = gamificationState.badges.map((badge) => {
        if (badge.id === badgeId && !badge.earned && (badge.progress || 0) >= badge.goal) {
          badgeAward = addXp(badge.xp, `${badge.title} badge`, { skipBonus: true });
          badgeTitle = badge.title;
          return { ...badge, earned: true };
        }
        return badge;
      });
      if (badgeAward) {
        logActivity(`Claimed badge: ${badgeTitle}`);
        saveState();
        renderAll();
      }
    }

    function openMiniGame(gameId) {
      const game = gamificationState.miniGames.find((item) => item.id === gameId);
      if (!game) return;
      const attempts = game.attempts || 0;
      const attemptsLeft = Math.max(0, game.maxAttempts - attempts);
      if (attemptsLeft <= 0) {
        showToast('All attempts used today. Come back after the daily reset.');
        return;
      }
      if (!miniGameDialog || !miniGameTitle || !miniGameBody) return;
      miniGameTitle.textContent = game.title;
      miniGameBody.innerHTML = '';
      miniGameBody.dataset.game = game.id;
      delete miniGameBody.dataset.correctAnswer;
      delete miniGameBody.dataset.correctExplanation;
      delete miniGameBody.dataset.questionId;

      const questionSet = MINI_GAME_BANK[game.type] || [];
      const question = randomItem(questionSet);

      if (question && typeof question === 'object') {
        miniGameBody.dataset.questionId = question.id || '';
        const lead = document.createElement('p');
        lead.className = 'dashboard-dialog__lead';
        lead.textContent = question.prompt || 'Ready for a new RouteFlow challenge?';
        miniGameBody.appendChild(lead);

        if (question.description) {
          const description = document.createElement('p');
          description.className = 'dashboard-dialog__copy';
          description.textContent = question.description;
          miniGameBody.appendChild(description);
        }

        if (question.hint) {
          const hint = document.createElement('p');
          hint.className = 'dashboard-mini__hint';
          hint.textContent = question.hint;
          miniGameBody.appendChild(hint);
        }

        const optionsWrapper = document.createElement('div');
        optionsWrapper.className = 'dashboard-dialog__options';
        const shuffledAnswers = shuffleArray(question.answers || []);
        const correctAnswer = (Array.isArray(question.answers) ? question.answers : []).find((answer) => answer && answer.correct) || null;
        shuffledAnswers.forEach((answer) => {
          if (!answer || typeof answer.text !== 'string') return;
          const button = document.createElement('button');
          button.type = 'button';
          button.dataset.answer = answer.correct ? 'correct' : 'wrong';
          if (answer.explanation) {
            button.dataset.explanation = answer.explanation;
          }
          button.textContent = answer.text;
          optionsWrapper.appendChild(button);
        });
        miniGameBody.appendChild(optionsWrapper);

        if (correctAnswer) {
          miniGameBody.dataset.correctAnswer = correctAnswer.text || '';
          if (correctAnswer.explanation) {
            miniGameBody.dataset.correctExplanation = correctAnswer.explanation;
          }
        }
      } else {
        const fallback = document.createElement('p');
        fallback.className = 'dashboard-dialog__lead';
        fallback.textContent = 'Mini game content is loading. Please try again in a moment.';
        miniGameBody.appendChild(fallback);
      }

      const attemptsMessage = document.createElement('p');
      attemptsMessage.className = 'dashboard-mini__hint dashboard-mini__hint--meta';
      attemptsMessage.textContent = `${attemptsLeft} attempt${attemptsLeft === 1 ? '' : 's'} left today`;
      miniGameBody.appendChild(attemptsMessage);

      if (typeof miniGameDialog.showModal === 'function') {
        miniGameDialog.showModal();
      }
    }

    function resolveMiniGame(gameId, success, context = {}) {
      const gameIndex = gamificationState.miniGames.findIndex((item) => item.id === gameId);
      if (gameIndex === -1) return;
      const game = gamificationState.miniGames[gameIndex];
      const attempts = game.attempts || 0;
      if (attempts >= game.maxAttempts) {
        showToast('All attempts used today.');
        return;
      }
      const updatedGame = { ...game, attempts: attempts + 1 };
      gamificationState.miniGames.splice(gameIndex, 1, updatedGame);
      if (success) {
        const awarded = addXp(game.xp, game.title);
        if (awarded) {
          logActivity(`Won mini game: ${game.title}`);
          registerComboProgress();
          updateChallenges('mini-win');
        }
        if (miniGameBody) {
          const explanation = miniGameBody.dataset.correctExplanation;
          const message = explanation
            ? `Great work — ${explanation}`
            : 'Great work — bonus XP secured.';
          miniGameBody.innerHTML = '';
          const result = document.createElement('p');
          result.className = 'dashboard-dialog__lead';
          result.textContent = message;
          miniGameBody.appendChild(result);
        }
      } else if (miniGameBody) {
        const answerText = miniGameBody.dataset.correctAnswer || 'the correct answer';
        const answerExplanation = miniGameBody.dataset.correctExplanation || '';
        const chosen = context.selectedText ? `You chose ${context.selectedText}. ` : '';
        const chosenExplanation = context.explanation ? `${context.explanation} ` : '';
        const message = `${chosen}${chosenExplanation}The correct answer was ${answerText}.${answerExplanation ? ` ${answerExplanation}` : ''}`;
        miniGameBody.innerHTML = '';
        const result = document.createElement('p');
        result.className = 'dashboard-dialog__lead';
        result.textContent = message;
        miniGameBody.appendChild(result);
      }
      saveState();
      renderMiniGames();
    }

    function resetTasks() {
      gamificationState.tasks = gamificationState.tasks.map((task) => ({ ...task, completed: false }));
      saveState();
      renderAll();
      showToast('Daily tasks reset. Fresh streak starts now.');
    }

    function logActivity(message) {
      if (!message) return;
      const uid = currentUid || 'guest';
      const key = `activity_${uid}`;
      try {
        const history = safeParse(localStorage.getItem(key)) || [];
        history.unshift(message);
        localStorage.setItem(key, JSON.stringify(history.slice(0, 12)));
      } catch (error) {
        console.warn('RouteFlow dashboard: unable to log activity', error);
      }
      loadActivity(uid);
    }

    function createFavouriteCard(uid, favourite) {
      const card = document.createElement('article');
      card.className = 'favourite-item';
      const header = document.createElement('div');
      header.className = 'favourite-item__header';
      const eyebrow = document.createElement('span');
      eyebrow.className = 'favourite-item__eyebrow';
      eyebrow.textContent = inferFavouriteType(favourite);
      header.appendChild(eyebrow);
      const removeButton = document.createElement('button');
      removeButton.type = 'button';
      removeButton.className = 'favourite-item__remove';
      removeButton.textContent = 'Remove';
      removeButton.addEventListener('click', async () => {
        if (!uid || !favourite?.id) return;
        try {
          removeButton.disabled = true;
          await removeFavourite(uid, favourite.id);
          await loadFavourites(uid);
        } catch (error) {
          console.error('Failed to remove favourite from dashboard view.', error);
          alert('We could not remove this favourite. Please try again.');
        } finally {
          removeButton.disabled = false;
        }
      });
      header.appendChild(removeButton);
      const title = resolveFavouriteTitle(favourite);
      const titleEl = document.createElement('h3');
      titleEl.className = 'favourite-item__title';
      titleEl.textContent = title;
      const metaParts = buildFavouriteMeta(favourite, title);
      card.append(header, titleEl);
      if (metaParts.length) {
        const metaEl = document.createElement('p');
        metaEl.className = 'favourite-item__meta';
        metaEl.textContent = metaParts.join(' • ');
        card.appendChild(metaEl);
      }
      return card;
    }

    async function loadFavourites(uid) {
      const grid = document.getElementById('favouritesGrid');
      if (!grid) return;
      grid.innerHTML = '';
      if (!uid || uid === 'guest') {
        const emptyState = document.createElement('p');
        emptyState.className = 'dashboard-empty';
        emptyState.textContent = 'Sign in to manage favourites.';
        grid.appendChild(emptyState);
        return;
      }
      try {
        const favourites = await getFavourites(uid);
        if (!Array.isArray(favourites) || favourites.length === 0) {
          const emptyState = document.createElement('p');
          emptyState.className = 'dashboard-empty';
          emptyState.textContent = 'No favourites saved yet.';
          grid.appendChild(emptyState);
          return;
        }
        favourites.forEach((favourite) => {
          grid.appendChild(createFavouriteCard(uid, favourite));
        });
      } catch (error) {
        console.error('Failed to load favourites for dashboard view.', error);
        const errorState = document.createElement('p');
        errorState.className = 'dashboard-empty';
        errorState.textContent = 'We could not load your favourites right now.';
        grid.appendChild(errorState);
      }
    }

    function loadRecents(uid) {
      const list = document.getElementById('recentsList');
      if (!list) return;
      list.innerHTML = '';
      const recents = getRecents(uid);
      if (!recents.length) {
        list.innerHTML = '<li>No recent items.</li>';
        return;
      }
      recents.forEach((recent) => {
        const li = document.createElement('li');
        const link = document.createElement('a');
        link.href = recent.url;
        link.textContent = recent.title || recent.url;
        li.appendChild(link);
        list.appendChild(li);
      });
    }

    function loadActivity(uid) {
      const list = document.getElementById('activityList');
      if (!list) return;
      list.innerHTML = '';
      const history = safeParse(localStorage.getItem(`activity_${uid}`)) || [];
      if (!history.length) {
        list.innerHTML = '<li>No recent activity.</li>';
        return;
      }
      history.forEach((entry) => {
        const li = document.createElement('li');
        li.textContent = entry;
        list.appendChild(li);
      });
    }

    function handleLock() {
      currentUid = 'guest';
      gamificationState = loadState(currentUid);
      ensureDailyState(gamificationState);
      updateDiscordConnection(getDiscordStatus(), { save: false, log: false, renderAll: false });
      if (titleElement) titleElement.textContent = 'Welcome';
      if (infoElement) infoElement.textContent = 'Sign in to save favourites and unlock missions, roles and streak bonuses.';
      if (avatarElement) avatarElement.src = 'user-icon.png';
      renderAll();
      loadActivity('guest');
      loadRecents('guest');
      const favouritesGrid = document.getElementById('favouritesGrid');
      if (favouritesGrid) {
        favouritesGrid.innerHTML = '<p class="dashboard-empty">Sign in to manage favourites.</p>';
      }
    }

    async function handleUnlock(user) {
      if (!user) return;
      currentUid = user.uid;
      gamificationState = loadState(currentUid);
      const { dayDifference } = ensureDailyState(gamificationState);
      updateDiscordConnection(getDiscordStatus(), { save: false, log: false, renderAll: false });
      if (titleElement) titleElement.textContent = `Welcome, ${user.email || 'Explorer'}`;
      if (infoElement) infoElement.textContent = 'Your rewards sync automatically across devices and Discord.';
      if (avatarElement) avatarElement.src = user.photoURL || 'user-icon.png';
      if (dayDifference === 1) {
        updateChallenges('streak');
      }
      renderAll();
      try {
        await loadFavourites(user.uid);
      } catch (error) {
        console.error('Failed to refresh favourites after sign in.', error);
      }
      loadActivity(user.uid);
      loadRecents(user.uid);
      saveState();
    }

    const handleAuthStateChange = (user) => {
      if (user) {
        if (guard) {
          guard.unlock({ user });
        } else {
          handleUnlock(user);
        }
      } else {
        if (guard) {
          guard.lock({ reason: 'signed-out', force: true });
        }
        handleLock();
      }
    };

    function subscribeToAuth() {
      const routeflowAuth = window.RouteflowAuth;
      if (routeflowAuth?.getCurrentUser) {
        try {
          handleAuthStateChange(routeflowAuth.getCurrentUser());
        } catch (error) {
          console.error('RouteFlow dashboard: failed to read initial auth state.', error);
        }
      }
      if (routeflowAuth?.subscribe) {
        routeflowAuth.subscribe(handleAuthStateChange);
        return;
      }

      const ensure = routeflowAuth?.ensure || window.ensureFirebaseAuth;
      if (typeof ensure !== 'function') {
        guard?.lock({ reason: 'auth-missing', force: true });
        handleLock();
        return;
      }

      ensure()
        .then((authInstance) => {
          if (!authInstance || typeof authInstance.onAuthStateChanged !== 'function') {
            guard?.lock({ reason: 'auth-missing', force: true });
            handleLock();
            return;
          }
          authInstance.onAuthStateChanged(handleAuthStateChange);
        })
        .catch((error) => {
          console.error('RouteFlow dashboard: failed to observe authentication state.', error);
          guard?.lock({ reason: 'auth-missing', force: true });
          handleLock();
        });
    }

    document.addEventListener('click', (event) => {
      const taskButton = event.target.closest('[data-task]');
      if (taskButton) {
        completeTask(taskButton.dataset.task);
        return;
      }
      const badgeButton = event.target.closest('[data-claim]');
      if (badgeButton) {
        claimBadge(badgeButton.dataset.claim);
        return;
      }
      const miniButton = event.target.closest('[data-mini-game]');
      if (miniButton) {
        openMiniGame(miniButton.dataset.miniGame);
        return;
      }
      const missionButton = event.target.closest('[data-mission]');
      if (missionButton) {
        completeMission(missionButton.dataset.mission);
      }
    });

    if (miniGameBody) {
      miniGameBody.addEventListener('click', (event) => {
        const answerButton = event.target.closest('[data-answer]');
        if (!answerButton) return;
        const gameId = miniGameBody.dataset.game;
        const context = {
          selectedText: answerButton.textContent?.trim() || '',
          explanation: answerButton.dataset.explanation || ''
        };
        resolveMiniGame(gameId, answerButton.dataset.answer === 'correct', context);
      });
    }

    if (discordButton) {
      discordButton.addEventListener('click', (event) => {
        event.preventDefault();
        const connected = Boolean(discordConnection?.connected);
        if (connected) {
          const confirmed = window.confirm('Disconnect your Discord account from RouteFlow London?');
          if (confirmed) {
            disconnectDiscord();
          }
          return;
        }
        if (!isDiscordConfigured()) {
          alert('Discord linking is not configured yet. Ask an administrator to provide a Discord client ID.');
          return;
        }
        try {
          showToast('Redirecting to Discord…');
        } catch (error) {
          // Ignore toast errors
        }
        try {
          connectDiscord();
        } catch (error) {
          console.error('Discord OAuth start failed', error);
          alert(error?.message || 'Discord linking is not available right now.');
        }
      });
    }

    if (resetTasksButton) {
      resetTasksButton.addEventListener('click', resetTasks);
    }

    updateDiscordConnection(discordConnection, { save: false, log: false, renderAll: false });
    unsubscribeDiscord = subscribeToDiscordStatus((status) => {
      const shouldLog = typeof status?.reason === 'string';
      updateDiscordConnection(status, { save: true, log: shouldLog, renderAll: shouldLog });
    });

    window.addEventListener('beforeunload', () => {
      if (typeof unsubscribeDiscord === 'function') {
        unsubscribeDiscord();
        unsubscribeDiscord = null;
      }
    });

    subscribeToAuth();
    renderAll();

  </script>
</body>
</html>
